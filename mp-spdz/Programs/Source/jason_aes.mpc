from circuit import Circuit

sb128 = sbits.get_type(128)
n = 1

IV_c = sb128.get_input_from(0)
IV_mb = sb128.get_input_from(1)



@if_e(IV_c.equal(IV_mb).reveal())
def _():
	Key = sb128.get_input_from(0)
	aes128 = Circuit('aes_128')
	e = aes128(sbitvec([Key] * n), sbitvec([IV_mb] * n))
	result = e.elements()[n - 1].reveal()
	print_ln("The keying material: %s", result)
@else_
def _():
	print_ln("Detected MB input error")


'''
if(  IV_c.equal(IV_mb).reveal() ):
	Key = sb128.get_input_from(0)
	aes128 = Circuit('aes_128')
	e = aes128(sbitvec([KeyS] * n), sbitvec([IV_mb] * n))
	result = e.elements()[n - 1].reveal()
	#print_ln("The keying material: %s", e.elements()[n - 1].reveal())
	print_ln("The keying material: %s", result)
else:
	print_ln("Detected MB input error")
'''


#test vector from SPDZ 57811460909138771071931939740208549692

#Following is hexstring for "Hellooo JasonLoh"
#hex 0x49206c6f7665204d656469756d616161)
#int 97201996522976691879970772078538350945





#print_ln("key = %s", key.reveal())
#print_ln("plaintext = %s", plaintext.reveal())




#print_ln("The final result: %s", ciphertexts.elements()[n - 1].reveal())


#print_ln_to(1,"Test: %s", key2.equal(plaintext).reveal())
#print_ln_if(key2.equal(plaintext).reveal(),"The final result: %s", ciphertexts.elements()[n - 1].reveal())


'''
@if_( key2.equal(plaintext).reveal() )
def _():
	print_ln("The final result: %s", ciphertexts.elements()[n - 1].reveal())
'''

